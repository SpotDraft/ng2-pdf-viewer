{"version":3,"file":"ng2-pdf-viewer-ngx-var-projects-ngx-var.mjs","sources":["../../ngx-var/projects/ngx-var/src/lib/ngx-var.directive.ts","../../ngx-var/projects/ngx-var/src/lib/ngx-var.module.ts","../../ngx-var/projects/ngx-var/src/public-api.ts","../../ngx-var/projects/ngx-var/src/ng2-pdf-viewer-ngx-var-projects-ngx-var.ts"],"sourcesContent":["import {\n  Directive,\n  Input,\n  OnInit,\n  TemplateRef,\n  ViewContainerRef,\n} from '@angular/core';\n\nexport class Context<T = unknown> {\n  /**\n   * The `$implicit` property powers the default `let-` syntax.\n   * Eg:\n   *\n   * ```\n   * <ng-container *ngxVar=\"isEnabled$ | async; let enabled\">\n   * ```\n   *  or\n   * ```\n   * <ng-container *ngxVar=\"isEnabled$ | async; let-enabled=ngxVar>\n   * ```\n   */\n  $implicit: T;\n  /**\n   * The name of this property *must* match the selector of the directive. This is\n   * because Angular desugars the microsyntax with this assumption. For Eg:\n   *\n   * ```\n   * <ng-container *ngxVar=\"isEnabled$ | async as enabled\">\n   * ```\n   * is syntactic sugar for -\n   *\n   * ```\n   * <ng-container *ngxVar=\"isEnabled$ | async\" let-enabled=\"ngxVar\">\n   * ```\n   *\n   */\n  ngxVar: T;\n}\n\n@Directive({\n  selector: '[ngxVar]',\n})\nexport class NgxVarDirective<T = unknown> implements OnInit {\n  private _context = new Context<T>();\n\n  @Input()\n  set ngxVar(value: T) {\n    this._context.$implicit = value;\n    this._context.ngxVar = value;\n  }\n\n  constructor(\n    private _vcr: ViewContainerRef,\n    private _templateRef: TemplateRef<Context<T>>\n  ) {}\n\n  ngOnInit() {\n    this._vcr.createEmbeddedView(this._templateRef, this._context);\n  }\n\n  /**\n   * Assert the correct type of the expression bound to the `ngxVar` input within the template.\n   *\n   * The presence of this static field is a signal to the Ivy template type check compiler that\n   * when the `ngxVar` structural directive renders its template, the type of the expression bound\n   * to `ngxVar` should be narrowed in some way. For `ngxVar`, the binding expression itself is used to\n   * narrow its type, which allows the strictNullChecks feature of TypeScript to work with `ngxVar`.\n   */\n  static ngTemplateGuard_ngxVar: 'binding';\n\n  /**\n   * Asserts the correct type of the context for the template that `ngxVar` will render.\n   *\n   * The presence of this method is a signal to the Ivy template type-check compiler that the\n   * `ngxVar` structural directive renders its template with a specific context type.\n   */\n  static ngTemplateContextGuard<T>(\n    dir: NgxVarDirective<T>,\n    ctx: any\n  ): ctx is Context<Exclude<T, false | 0 | '' | null | undefined>> {\n    return true;\n  }\n}\n","import { NgModule } from '@angular/core';\n\nimport { NgxVarDirective } from './ngx-var.directive';\n\n@NgModule({\n  declarations: [NgxVarDirective],\n  imports: [],\n  exports: [NgxVarDirective],\n})\nexport class NgxVarModule {}\n","/*\n * Public API Surface of ngx-var\n */\nexport * from './lib/ngx-var.module';\nexport * from './lib/ngx-var.directive';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":";;;MAQa,OAAO;CA6BnB;MAKY,eAAe;IAS1B,YACU,IAAsB,EACtB,YAAqC;QADrC,SAAI,GAAJ,IAAI,CAAkB;QACtB,iBAAY,GAAZ,YAAY,CAAyB;QAVvC,aAAQ,GAAG,IAAI,OAAO,EAAK,CAAC;KAWhC;IATJ,IACI,MAAM,CAAC,KAAQ;QACjB,IAAI,CAAC,QAAQ,CAAC,SAAS,GAAG,KAAK,CAAC;QAChC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,KAAK,CAAC;KAC9B;IAOD,QAAQ;QACN,IAAI,CAAC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;KAChE;;;;;;;IAkBD,OAAO,sBAAsB,CAC3B,GAAuB,EACvB,GAAQ;QAER,OAAO,IAAI,CAAC;KACb;;4GAvCU,eAAe;gGAAf,eAAe;2FAAf,eAAe;kBAH3B,SAAS;mBAAC;oBACT,QAAQ,EAAE,UAAU;iBACrB;iIAKK,MAAM;sBADT,KAAK;;;MCpCK,YAAY;;yGAAZ,YAAY;0GAAZ,YAAY,iBAJR,eAAe,aAEpB,eAAe;0GAEd,YAAY,YAHd,EAAE;2FAGA,YAAY;kBALxB,QAAQ;mBAAC;oBACR,YAAY,EAAE,CAAC,eAAe,CAAC;oBAC/B,OAAO,EAAE,EAAE;oBACX,OAAO,EAAE,CAAC,eAAe,CAAC;iBAC3B;;;ACRD;;;;ACAA;;;;;;"}